# Ansible Roles

Ansible roles provide a well-defined framework and structure for setting your tasks, variables, handlers, metadata, templates, and other files. They enable us to reuse and share our Ansible code efficiently. This way, we can reference and call them in our playbooks with just a few lines of code while we can reuse the same roles over many projects without the need to duplicate our code.

## Why roles are useful in Ansible

Organizing our Ansible content into roles provides a more manageable structure than using playbooks alone. This might not be evident in minimal projects but as the number of playbooks grows, so does the complexity of our projects.

Placing our Ansible code into roles lets us organize our automation projects into logical groupings and follow the separation of concerns design principle. Collaboration and velocity are also improved since different users can work on separate roles in parallel without modifying the same playbooks simultaneously.

## Ansible role structure

For each role, we define a directory with the same name. Inside, files are grouped into subdirectories according to their function. A role must include at least one of these standard directories and can omit any that isn’t actively used.

To assist us with quickly creating a well-defined role directory structure skeleton, we can leverage the command *ansible-galaxy init <your_role_name>*. The ansible-galaxy command comes bundled with Ansible, so there is no need to install extra packages.

Ansible checks for main.yml files, possible variations, and relevant content in each subdirectory. It’s possible to include additional YAML files in some directories. For instance, you can group your tasks in separate YAML files according to some characteristic.

- **defaults** – Includes default values for variables of the role. Here we define some sane default variables, but they have the lowest priority and are usually overridden by other methods to customize the role.
- **files**  – Contains static and custom files that the role uses to perform various tasks.
- **handlers** – A set of handlers that are triggered by tasks of the role.
- **meta** – Includes metadata information for the role, its dependencies, the author, license, available platform, etc.
- **tasks** – A list of tasks to be executed by the role. This part could be considered similar to the task section of a playbook.
- **templates** – Contains Jinja2 template files used by tasks of the role. (Read more about how to create an Ansible template.)
- **tests** – Includes configuration files related to role testing.
- **vars** – Contains variables defined for the role. These have quite a high precedence in Ansible.

Another directory that wasn’t automatically generated by the ansible-galaxy init command but is mentioned in the official Ansible docs, and you might find helpful in some cases, is the library directory. Inside it, we define any custom modules and plugins that we have written and used by the role. Finally, we also have a preconfigured README.md file that we can fill with details and useful information about our role.

## Creating Ansible roles

Ansible searches for referenced roles in common paths like the orchestrating playbook’s directory, the roles/ directory, or the configured roles_path configuration value. It’s also possible to set a custom path when referencing a role:

```yml
- hosts: all
  roles:
    - role: "/custom_path/to/the/role"
```

Full step by step guide on creating a tutorial server role [here](https://spacelift.io/blog/ansible-roles)

## Using Ansible roles - An example

Once we have defined all the necessary parts of our role, it’s time to use it in plays. The classic and most obvious way is to reference a role at the play level with the roles option:

```yml
- hosts: all
  become: true
  roles:
    - webserver
```

With this option, each role defined in our playbook is executed before any other tasks defined in the play.
